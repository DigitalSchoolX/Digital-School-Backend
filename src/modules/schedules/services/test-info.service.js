const TestInfo = require("../models/test-info.model");
const Lesson = require("../models/lesson.model");
const User = require("../../auth/models/user.model");
const emailService = require("../../auth/services/email.service");

const testTypeNames = {
  kiemtra15: "Ki·ªÉm tra 15 ph√∫t",
  kiemtra1tiet: "Ki·ªÉm tra 1 ti·∫øt",
  kiemtrathuchanh: "Ki·ªÉm tra th·ª±c h√†nh",
  kiemtramieng: "Ki·ªÉm tra mi·ªáng",
  baitap: "B√†i t·∫≠p",
  other: "Ki·ªÉm tra kh√°c",
};
const priorityNames = {
  low: "Th·∫•p",
  medium: "Trung b√¨nh",
  high: "Cao",
  urgent: "Kh·∫©n c·∫•p",
};
const priorityColors = {
  low: "#28a745",
  medium: "#ffc107",
  high: "#fd7e14",
  urgent: "#dc3545",
};

function createTestInfoEmailTemplate(testInfoData, studentName) {
  const {
    lesson,
    class: classInfo,
    subject,
    testType,
    title,
    content,
    expectedTestDate,
    priority,
    chapters,
    references,
  } = testInfoData;

  // Format ng√†y gi·ªù ti·∫øt h·ªçc
  const lessonDate = new Date(lesson.scheduledDate);
  const formatDate = lessonDate.toLocaleDateString("vi-VN", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  });
  const formatTime = lessonDate.toLocaleTimeString("vi-VN", {
    hour: "2-digit",
    minute: "2-digit",
  });

  return `
    <div style="font-family: 'Segoe UI', Arial, sans-serif; max-width: 700px; margin: 0 auto; background-color: #f8f9fa;">
      <!-- Header -->
      <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px 20px; text-align: center;">
        <h1 style="margin: 0; font-size: 28px; font-weight: 300; color: black">üîî TH√îNG B√ÅO KI·ªÇM TRA</h1>
        <p style="margin: 10px 0 0; font-size: 16px; opacity: 0.9; color: black">H·ªá th·ªëng qu·∫£n l√Ω tr∆∞·ªùng h·ªçc EcoSchool</p>
      </div>
      
      <!-- Greeting -->
      <div style="padding: 30px 20px 20px; background: white;">
        <h2 style="color: #2c3e50; margin: 0 0 15px; font-size: 22px;">Xin ch√†o ${studentName}!</h2>
        <p style="color: #666; font-size: 16px; line-height: 1.6; margin: 0;">
          Gi√°o vi√™n ƒë√£ t·∫°o th√¥ng b√°o nh·∫Øc nh·ªü v·ªÅ b√†i ki·ªÉm tra s·∫Øp t·ªõi. Vui l√≤ng xem th√¥ng tin chi ti·∫øt b√™n d∆∞·ªõi.
        </p>
      </div>
      
      <!-- Main Content -->
      <div style="background: white; padding: 0 20px 20px;">
        <!-- Test Info Card -->
        <div style="border: 2px solid #e9ecef; border-radius: 10px; overflow: hidden; margin-bottom: 25px;">
          <div style="background: #f8f9fa; padding: 15px; border-bottom: 1px solid #e9ecef;">
            <h3 style="margin: 0; color: #495057; font-size: 18px;">üìã ${title}</h3>
          </div>
          <div style="padding: 20px;">
            <div style="display: grid; gap: 15px;">
              <div style="display: flex; align-items: center;">
                <span style="font-weight: 600; color: #495057; width: 120px; display: inline-block;">üìö M√¥n h·ªçc:</span>
                <span style="color: #007bff; font-weight: 500;">${
                  subject.name
                } (${subject.code})</span>
              </div>
              <div style="display: flex; align-items: center;">
                <span style="font-weight: 600; color: #495057; width: 120px; display: inline-block;">üè´ L·ªõp:</span>
                <span style="color: #28a745; font-weight: 500;">${
                  classInfo.className
                }</span>
              </div>
              <div style="display: flex; align-items: center;">
                <span style="font-weight: 600; color: #495057; width: 120px; display: inline-block;">üìù Lo·∫°i:</span>
                <span style="color: #6f42c1; font-weight: 500;">${
                  testTypeNames[testType] || testType
                }</span>
              </div>
              <div style="display: flex; align-items: center;">
                <span style="font-weight: 600; color: #495057; width: 120px; display: inline-block;">‚ö° M·ª©c ƒë·ªô:</span>
                <span style="background: ${
                  priorityColors[priority]
                }; color: white; padding: 4px 12px; border-radius: 15px; font-size: 12px; font-weight: 600; text-transform: uppercase;">
                  ${priorityNames[priority] || priority}
                </span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Date Time Card -->
        <div style="background: linear-gradient(135deg, #ff6b6b, #ee5a24); color: white; border-radius: 10px; padding: 25px; margin-bottom: 25px; text-align: center;">
          <h3 style="margin: 0 0 15px; font-size: 20px;">üìÖ TH·ªúI GIAN TI·∫æT H·ªåC</h3>
          <div style="background: rgba(255,255,255,0.2); border-radius: 8px; padding: 15px; margin: 15px 0;">
            <div style="font-size: 18px; font-weight: 600; margin-bottom: 5px;">${formatDate}</div>
            <div style="font-size: 24px; font-weight: 700;">${formatTime}</div>
          </div>
          <p style="margin: 15px 0 0; font-size: 14px; opacity: 0.9;">
            Th·ªùi gian di·ªÖn ra ti·∫øt h·ªçc c√≥ ki·ªÉm tra
          </p>
        </div>
        
        <!-- Content -->
        <div style="border-left: 4px solid #007bff; background: #f8f9fa; padding: 20px; margin-bottom: 25px;">
          <h4 style="margin: 0 0 15px; color: #495057; font-size: 16px;">üìñ N·ªòI DUNG KI·ªÇM TRA:</h4>
          <p style="margin: 0; color: #666; line-height: 1.6; font-size: 15px;">${content}</p>
        </div>
        
        ${
          chapters && chapters.length > 0
            ? `
        <!-- Chapters -->
        <div style="margin-bottom: 25px;">
          <h4 style="color: #495057; font-size: 16px; margin: 0 0 15px;">üìö CH∆Ø∆†NG/B√ÄI C·∫¶N √îN T·∫¨P:</h4>
          ${chapters
            .map(
              (chapter) => `
            <div style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
              <h5 style="color: #007bff; margin: 0 0 10px; font-size: 15px;">${
                chapter.chapterName
              }</h5>
              ${
                chapter.topics && chapter.topics.length > 0
                  ? `
                <ul style="margin: 0; padding-left: 20px; color: #666;">
                  ${chapter.topics
                    .map(
                      (topic) => `<li style="margin-bottom: 5px;">${topic}</li>`
                    )
                    .join("")}
                </ul>
              `
                  : ""
              }
            </div>
          `
            )
            .join("")}
        </div>
        `
            : ""
        }
        
        ${
          references && references.length > 0
            ? `
        <!-- References -->
        <div style="margin-bottom: 25px;">
          <h4 style="color: #495057; font-size: 16px; margin: 0 0 15px;">üìñ T√ÄI LI·ªÜU THAM KH·∫¢O:</h4>
          ${references
            .map(
              (ref) => `
            <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 10px; border-radius: 0 8px 8px 0;">
              <h6 style="margin: 0 0 8px; color: #1976d2; font-size: 14px;">${
                ref.title
              }</h6>
              ${
                ref.description
                  ? `<p style="margin: 0 0 8px; color: #666; font-size: 13px;">${ref.description}</p>`
                  : ""
              }
              ${
                ref.url
                  ? `<a href="${ref.url}" style="color: #1976d2; text-decoration: none; font-size: 13px;">üîó Xem t√†i li·ªáu</a>`
                  : ""
              }
            </div>
          `
            )
            .join("")}
        </div>
        `
            : ""
        }
        
        <!-- Tips -->
        <div style="background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 20px; margin-bottom: 25px;">
          <h4 style="color: #155724; margin: 0 0 15px; font-size: 16px;">üí° KHUY·∫æN NGH·ªä:</h4>
          <ul style="margin: 0; padding-left: 20px; color: #155724; line-height: 1.8;">
            <li>√în t·∫≠p k·ªπ l√Ω thuy·∫øt v√† l√†m b√†i t·∫≠p th·ª±c h√†nh</li>
            <li>Chu·∫©n b·ªã ƒë·∫ßy ƒë·ªß d·ª•ng c·ª•: b√∫t, th∆∞·ªõc, m√°y t√≠nh (n·∫øu c·∫ßn)</li>
            <li>C√≥ m·∫∑t ƒë√∫ng gi·ªù, kh√¥ng ƒë∆∞·ª£c ph√©p ƒë·∫øn mu·ªôn</li>
            <li>Gi·ªØ g√¨n tr·∫≠t t·ª± v√† kh√¥ng gian thi c·ª≠ nghi√™m t√∫c</li>
            <li>H·ªèi gi√°o vi√™n n·∫øu c√≥ th·∫Øc m·∫Øc v·ªÅ n·ªôi dung ki·ªÉm tra</li>
          </ul>
        </div>
      </div>
      
      <!-- Footer -->
      <div style="background: #343a40; color: white; padding: 20px; text-align: center;">
        <p style="margin: 0 0 10px; font-size: 14px;">
          Ch√∫c b·∫°n √¥n t·∫≠p t·ªët v√† ƒë·∫°t k·∫øt qu·∫£ cao! üåü
        </p>
        <hr style="border: none; border-top: 1px solid #495057; margin: 15px 0;">
        <p style="margin: 0; font-size: 12px; color: #adb5bd;">
          Email n√†y ƒë∆∞·ª£c g·ª≠i t·ª± ƒë·ªông t·ª´ h·ªá th·ªëng EcoSchool<br>
          Vui l√≤ng kh√¥ng ph·∫£n h·ªìi email n√†y
        </p>
      </div>
    </div>
  `;
}

function createCancelTestInfoEmailTemplate(testInfoData, studentName) {
  const {
    lesson,
    class: classInfo,
    subject,
    testType,
    title,
    content,
    expectedTestDate,
  } = testInfoData;

  // Format ng√†y gi·ªù ti·∫øt h·ªçc
  const lessonDate = new Date(lesson.scheduledDate);
  const formatDate = lessonDate.toLocaleDateString("vi-VN", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  });
  const formatTime = lessonDate.toLocaleTimeString("vi-VN", {
    hour: "2-digit",
    minute: "2-digit",
  });

  return `
    <div style="font-family: 'Segoe UI', Arial, sans-serif; max-width: 700px; margin: 0 auto; background-color: #f8f9fa;">
      <!-- Header -->
      <div style="background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white; padding: 30px 20px; text-align: center;">
        <h1 style="margin: 0; font-size: 28px; font-weight: 300; color: black">‚ùå TH√îNG B√ÅO H·ª¶Y KI·ªÇM TRA</h1>
        <p style="margin: 10px 0 0; font-size: 16px; opacity: 0.9; color: black">H·ªá th·ªëng qu·∫£n l√Ω tr∆∞·ªùng h·ªçc EcoSchool</p>
      </div>
      
      <!-- Greeting -->
      <div style="padding: 30px 20px 20px; background: white;">
        <h2 style="color: #2c3e50; margin: 0 0 15px; font-size: 22px;">Xin ch√†o ${studentName}!</h2>
        <p style="color: #666; font-size: 16px; line-height: 1.6; margin: 0;">
          Gi√°o vi√™n ƒë√£ <strong style="color: #dc3545;">H·ª¶Y</strong> th√¥ng b√°o nh·∫Øc nh·ªü ki·ªÉm tra. Vui l√≤ng xem th√¥ng tin chi ti·∫øt b√™n d∆∞·ªõi.
        </p>
      </div>
      
      <!-- Main Content -->
      <div style="background: white; padding: 0 20px 20px;">
        <!-- Cancel Notice -->
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 10px; padding: 20px; margin-bottom: 25px; text-align: center;">
          <h3 style="color: #721c24; margin: 0 0 10px; font-size: 20px;">üö´ KI·ªÇM TRA ƒê√É B·ªä H·ª¶Y</h3>
          <p style="color: #721c24; margin: 0; font-size: 16px;">
            B√†i ki·ªÉm tra d∆∞·ªõi ƒë√¢y ƒë√£ ƒë∆∞·ª£c gi√°o vi√™n h·ªßy b·ªè. B·∫°n kh√¥ng c·∫ßn chu·∫©n b·ªã cho b√†i ki·ªÉm tra n√†y n·ªØa.
          </p>
        </div>
        
        <!-- Test Info Card -->
        <div style="border: 2px solid #dc3545; border-radius: 10px; overflow: hidden; margin-bottom: 25px; opacity: 0.8;">
          <div style="background: #dc3545; color: white; padding: 15px; border-bottom: 1px solid #c82333;">
            <h3 style="margin: 0; font-size: 18px;">üìã ${title} (ƒê√É H·ª¶Y)</h3>
          </div>
          <div style="padding: 20px; background: #f8f9fa;">
            <div style="display: grid; gap: 15px;">
              <div style="display: flex; align-items: center;">
                <span style="font-weight: 600; color: #495057; width: 120px; display: inline-block;">üìö M√¥n h·ªçc:</span>
                <span style="color: #007bff; font-weight: 500;">${
                  subject.name
                } (${subject.code})</span>
              </div>
              <div style="display: flex; align-items: center;">
                <span style="font-weight: 600; color: #495057; width: 120px; display: inline-block;">üè´ L·ªõp:</span>
                <span style="color: #28a745; font-weight: 500;">${
                  classInfo.className
                }</span>
              </div>
              <div style="display: flex; align-items: center;">
                <span style="font-weight: 600; color: #495057; width: 120px; display: inline-block;">üìù Lo·∫°i:</span>
                <span style="color: #6f42c1; font-weight: 500;">${
                  testTypeNames[testType] || testType
                }</span>
              </div>
              <div style="display: flex; align-items: center;">
                <span style="font-weight: 600; color: #495057; width: 120px; display: inline-block;">üìÖ Ti·∫øt h·ªçc:</span>
                <span style="color: #dc3545; font-weight: 500; text-decoration: line-through;">
                  ${formatDate} - ${formatTime}
                </span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Content -->
        <div style="border-left: 4px solid #dc3545; background: #f8f9fa; padding: 20px; margin-bottom: 25px;">
          <h4 style="margin: 0 0 15px; color: #495057; font-size: 16px;">üìñ N·ªòI DUNG ƒê√É H·ª¶Y:</h4>
          <p style="margin: 0; color: #666; line-height: 1.6; font-size: 15px; text-decoration: line-through; opacity: 0.7;">${content}</p>
        </div>
        
        <!-- Notice -->
        <div style="background: #d1ecf1; border: 1px solid #bee5eb; border-radius: 8px; padding: 20px; margin-bottom: 25px;">
          <h4 style="color: #0c5460; margin: 0 0 15px; font-size: 16px;">üì¢ L∆ØU √ù QUAN TR·ªåNG:</h4>
          <ul style="margin: 0; padding-left: 20px; color: #0c5460; line-height: 1.8;">
            <li>B√†i ki·ªÉm tra n√†y ƒë√£ ƒë∆∞·ª£c h·ªßy b·ªè ho√†n to√†n</li>
            <li>B·∫°n kh√¥ng c·∫ßn chu·∫©n b·ªã hay √¥n t·∫≠p cho b√†i ki·ªÉm tra n√†y</li>
            <li>N·∫øu c√≥ b√†i ki·ªÉm tra thay th·∫ø, gi√°o vi√™n s·∫Ω th√¥ng b√°o ri√™ng</li>
            <li>Vui l√≤ng li√™n h·ªá gi√°o vi√™n n·∫øu c√≥ th·∫Øc m·∫Øc</li>
            <li>Ti·∫øp t·ª•c theo d√µi email ƒë·ªÉ nh·∫≠n th√¥ng b√°o m·ªõi</li>
          </ul>
        </div>
      </div>
      
      <!-- Footer -->
      <div style="background: #343a40; color: white; padding: 20px; text-align: center;">
        <p style="margin: 0 0 10px; font-size: 14px;">
          C·∫£m ∆°n b·∫°n ƒë√£ quan t√¢m! üìö
        </p>
        <hr style="border: none; border-top: 1px solid #495057; margin: 15px 0;">
        <p style="margin: 0; font-size: 12px; color: #adb5bd;">
          Email n√†y ƒë∆∞·ª£c g·ª≠i t·ª± ƒë·ªông t·ª´ h·ªá th·ªëng EcoSchool<br>
          Vui l√≤ng kh√¥ng ph·∫£n h·ªìi email n√†y
        </p>
      </div>
    </div>
  `;
}

class TestInfoService {
  async createTestInfo({ user, params, body }) {
    const { lessonId } = params;
    const {
      testType,
      title,
      content,
      chapters,
      references,
      expectedTestDate,
      testInfoDate,
      priority,
      reminder,
    } = body;
    const teacherId = user._id;
    // T√¨m lesson v√† populate th√¥ng tin c·∫ßn thi·∫øt
    const lesson = await Lesson.findById(lessonId)
      .populate("class", "_id className")
      .populate("subject", "_id subjectName subjectCode");
    if (!lesson) {
      return {
        status: 404,
        body: { success: false, message: "Lesson not found" },
      };
    }
    if (lesson.status !== "scheduled") {
      return {
        status: 400,
        body: {
          success: false,
          message: "Can only create test info for scheduled lessons",
        },
      };
    }
    if (lesson.teacher.toString() !== teacherId.toString()) {
      return {
        status: 403,
        body: {
          success: false,
          message: "You can only create test info for your own lessons",
        },
      };
    }
    // Ki·ªÉm tra ƒë√£ c√≥ test info cho lesson n√†y ch∆∞a
    const existingTestInfo = await TestInfo.findOne({ lesson: lessonId });
    if (existingTestInfo) {
      return {
        status: 409,
        body: {
          success: false,
          message: "Test info already exists for this lesson",
        },
      };
    }
    // N·∫øu kh√¥ng c√≥ expectedTestDate, t·∫°o m·∫∑c ƒë·ªãnh l√† 7 ng√†y sau
    const defaultTestDate = new Date();
    defaultTestDate.setDate(defaultTestDate.getDate() + 7);
    const testInfo = new TestInfo({
      lesson: lessonId,
      teacher: teacherId,
      class: lesson.class._id,
      subject: lesson.subject._id,
      testType: testType || "kiemtra15",
      title,
      content,
      chapters: chapters || [],
      references: references || [],
      expectedTestDate: expectedTestDate
        ? new Date(expectedTestDate)
        : defaultTestDate,
      testInfoDate: testInfoDate ? new Date(testInfoDate) : new Date(),
      priority: priority || "medium",
      reminder: reminder || "",
    });
    await testInfo.save();
    await testInfo.populate([
      { path: "lesson", select: "lessonId scheduledDate topic" },
      { path: "class", select: "className" },
      { path: "subject", select: "subjectName subjectCode" },
      { path: "teacher", select: "name" },
    ]);
    // L·∫•y danh s√°ch h·ªçc sinh trong l·ªõp ƒë·ªÉ g·ª≠i email
    const students = await User.find({
      class_id: lesson.class._id,
      role: { $in: ["student"] },
      email: { $exists: true, $ne: null, $ne: "" },
    }).select("_id name email studentId");
    // Chu·∫©n b·ªã d·ªØ li·ªáu cho email
    const testInfoEmailData = {
      lesson: {
        lessonId: testInfo.lesson.lessonId,
        scheduledDate: testInfo.lesson.scheduledDate,
        topic: testInfo.lesson.topic,
      },
      class: { className: testInfo.class.className },
      subject: {
        name: testInfo.subject.subjectName,
        code: testInfo.subject.subjectCode,
      },
      testType: testInfo.testType,
      title: testInfo.title,
      content: testInfo.content,
      chapters: testInfo.chapters,
      references: testInfo.references,
      expectedTestDate: testInfo.expectedTestDate,
      priority: testInfo.priority,
      reminder: testInfo.reminder,
    };
    // G·ª≠i email cho h·ªçc sinh (async, kh√¥ng ch·ªù k·∫øt qu·∫£)
    if (students.length > 0) {
      this.sendTestInfoToStudents(testInfoEmailData, students)
        .then((emailResults) => {
          console.log(
            `üìß Email sending completed: ${emailResults.successCount}/${emailResults.totalStudents} successful`
          );
        })
        .catch((error) => {
          console.error("‚ùå Error sending test info emails:", error.message);
        });
    }
    return {
      status: 201,
      body: {
        success: true,
        message: "T·∫°o th√¥ng tin ki·ªÉm tra th√†nh c√¥ng",
        data: {
          testInfoId: testInfo._id,
          lesson: {
            lessonId: testInfo.lesson.lessonId,
            scheduledDate: testInfo.lesson.scheduledDate,
            topic: testInfo.lesson.topic,
          },
          class: testInfo.class.className,
          subject: {
            name: testInfo.subject.subjectName,
            code: testInfo.subject.subjectCode,
          },
          teacher: testInfo.teacher.name,
          testType: testInfo.testType,
          title: testInfo.title,
          content: testInfo.content,
          chapters: testInfo.chapters,
          references: testInfo.references,
          expectedTestDate: testInfo.expectedTestDate,
          testInfoDate: testInfo.testInfoDate,
          priority: testInfo.priority,
          status: testInfo.status,
          reminder: testInfo.reminder,
          createdAt: testInfo.createdAt,
          emailInfo: {
            studentsFound: students.length,
            emailsSent:
              students.length > 0
                ? "ƒêang g·ª≠i email..."
                : "Kh√¥ng c√≥ h·ªçc sinh n√†o c√≥ email",
          },
        },
      },
    };
  }
  async getTeacherTestInfos({ user, query }) {
    const teacherId = user._id;
    const {
      status,
      priority,
      testType,
      startDate,
      endDate,
      page = 1,
      limit = 20,
    } = query;
    const options = {};
    if (status) options.status = status;
    if (priority) options.priority = priority;
    if (testType) options.testType = testType;
    if (startDate) options.startDate = new Date(startDate);
    if (endDate) options.endDate = new Date(endDate);
    const skip = (parseInt(page) - 1) * parseInt(limit);
    const testInfos = await TestInfo.getTeacherTestInfos(teacherId, options)
      .skip(skip)
      .limit(parseInt(limit));
    const total = await TestInfo.countDocuments({
      teacher: teacherId,
      ...(options.status && { status: options.status }),
      ...(options.priority && { priority: options.priority }),
      ...(options.testType && { testType: options.testType }),
      ...(options.startDate && {
        expectedTestDate: { $gte: options.startDate },
      }),
      ...(options.endDate && {
        expectedTestDate: { ...{}, $lte: options.endDate },
      }),
    });
    const totalPages = Math.ceil(total / parseInt(limit));
    return {
      status: 200,
      body: {
        success: true,
        message: "L·∫•y danh s√°ch th√¥ng tin ki·ªÉm tra th√†nh c√¥ng",
        data: {
          testInfos: testInfos.map((testInfo) => ({
            testInfoId: testInfo._id,
            lesson: {
              lessonId: testInfo.lesson.lessonId,
              scheduledDate: testInfo.lesson.scheduledDate,
              topic: testInfo.lesson.topic,
            },
            class: testInfo.class.className,
            subject: {
              name: testInfo.subject.subjectName,
              code: testInfo.subject.subjectCode,
            },
            testType: testInfo.testType,
            title: testInfo.title,
            content: testInfo.content,
            expectedTestDate: testInfo.expectedTestDate,
            testInfoDate: testInfo.testInfoDate,
            priority: testInfo.priority,
            status: testInfo.status,
            reminder: testInfo.reminder,
            createdAt: testInfo.createdAt,
            updatedAt: testInfo.updatedAt,
          })),
          pagination: {
            currentPage: parseInt(page),
            totalPages,
            totalItems: total,
            itemsPerPage: parseInt(limit),
          },
        },
      },
    };
  }
  async getTestInfoDetail({ user, params }) {
    const { testInfoId } = params;
    const teacherId = user._id;
    const testInfo = await TestInfo.findById(testInfoId)
      .populate("lesson", "lessonId scheduledDate topic")
      .populate("class", "className")
      .populate("subject", "subjectName subjectCode")
      .populate("teacher", "name");
    if (!testInfo) {
      return {
        status: 404,
        body: { success: false, message: "Test info not found" },
      };
    }
    if (testInfo.teacher._id.toString() !== teacherId.toString()) {
      return {
        status: 403,
        body: {
          success: false,
          message: "You can only view your own test info",
        },
      };
    }
    return {
      status: 200,
      body: {
        success: true,
        message: "L·∫•y chi ti·∫øt th√¥ng tin ki·ªÉm tra th√†nh c√¥ng",
        data: {
          testInfoId: testInfo._id,
          lesson: {
            lessonId: testInfo.lesson.lessonId,
            scheduledDate: testInfo.lesson.scheduledDate,
            topic: testInfo.lesson.topic,
          },
          class: testInfo.class.className,
          subject: {
            name: testInfo.subject.subjectName,
            code: testInfo.subject.subjectCode,
          },
          teacher: testInfo.teacher.name,
          testType: testInfo.testType,
          title: testInfo.title,
          content: testInfo.content,
          chapters: testInfo.chapters,
          references: testInfo.references,
          expectedTestDate: testInfo.expectedTestDate,
          testInfoDate: testInfo.testInfoDate,
          priority: testInfo.priority,
          status: testInfo.status,
          reminder: testInfo.reminder,
          isVisible: testInfo.isVisible,
          createdAt: testInfo.createdAt,
          updatedAt: testInfo.updatedAt,
        },
      },
    };
  }
  async updateTestInfo({ user, params, body }) {
    const { testInfoId } = params;
    const {
      testType,
      title,
      content,
      chapters,
      references,
      expectedTestDate,
      testInfoDate,
      priority,
      reminder,
    } = body;
    const teacherId = user._id;
    const testInfo = await TestInfo.findById(testInfoId);
    if (!testInfo) {
      return {
        status: 404,
        body: { success: false, message: "Test info not found" },
      };
    }
    if (testInfo.teacher.toString() !== teacherId.toString()) {
      return {
        status: 403,
        body: {
          success: false,
          message: "You can only update your own test info",
        },
      };
    }
    if (testInfo.status === "completed") {
      return {
        status: 400,
        body: { success: false, message: "Cannot update completed test info" },
      };
    }
    if (testType) testInfo.testType = testType;
    if (title) testInfo.title = title;
    if (content) testInfo.content = content;
    if (chapters !== undefined) testInfo.chapters = chapters;
    if (references !== undefined) testInfo.references = references;
    if (expectedTestDate)
      testInfo.expectedTestDate = new Date(expectedTestDate);
    if (testInfoDate) testInfo.testInfoDate = new Date(testInfoDate);
    if (priority) testInfo.priority = priority;
    if (reminder !== undefined) testInfo.reminder = reminder;
    await testInfo.save();
    await testInfo.populate([
      { path: "lesson", select: "lessonId scheduledDate topic" },
      { path: "class", select: "className" },
      { path: "subject", select: "subjectName subjectCode" },
    ]);
    return {
      status: 200,
      body: {
        success: true,
        message: "C·∫≠p nh·∫≠t th√¥ng tin ki·ªÉm tra th√†nh c√¥ng",
        data: {
          testInfoId: testInfo._id,
          testType: testInfo.testType,
          title: testInfo.title,
          content: testInfo.content,
          chapters: testInfo.chapters,
          references: testInfo.references,
          expectedTestDate: testInfo.expectedTestDate,
          testInfoDate: testInfo.testInfoDate,
          priority: testInfo.priority,
          status: testInfo.status,
          reminder: testInfo.reminder,
          updatedAt: testInfo.updatedAt,
        },
      },
    };
  }
  async deleteTestInfo({ user, params }) {
    const { testInfoId } = params;
    const teacherId = user._id;
    const testInfo = await TestInfo.findById(testInfoId)
      .populate("lesson", "lessonId scheduledDate topic")
      .populate("class", "_id className")
      .populate("subject", "subjectName subjectCode")
      .populate("teacher", "name");
    if (!testInfo) {
      return {
        status: 404,
        body: { success: false, message: "Test info not found" },
      };
    }
    if (testInfo.teacher._id.toString() !== teacherId.toString()) {
      return {
        status: 403,
        body: {
          success: false,
          message: "You can only delete your own test info",
        },
      };
    }
    const students = await User.find({
      class_id: testInfo.class._id,
      role: { $in: ["student"] },
      email: { $exists: true, $ne: null, $ne: "" },
    }).select("_id name email studentId");
    const testInfoEmailData = {
      lesson: {
        lessonId: testInfo.lesson.lessonId,
        scheduledDate: testInfo.lesson.scheduledDate,
        topic: testInfo.lesson.topic,
      },
      class: { className: testInfo.class.className },
      subject: {
        name: testInfo.subject.subjectName,
        code: testInfo.subject.subjectCode,
      },
      testType: testInfo.testType,
      title: testInfo.title,
      content: testInfo.content,
      chapters: testInfo.chapters,
      references: testInfo.references,
      expectedTestDate: testInfo.expectedTestDate,
      priority: testInfo.priority,
      reminder: testInfo.reminder,
    };
    await TestInfo.findByIdAndDelete(testInfoId);
    if (students.length > 0) {
      this.sendCancelTestInfoToStudents(testInfoEmailData, students)
        .then((emailResults) => {
          console.log(
            `üìß Cancellation email sending completed: ${emailResults.successCount}/${emailResults.totalStudents} successful`
          );
        })
        .catch((error) => {
          console.error("‚ùå Error sending cancellation emails:", error.message);
        });
    }
    return {
      status: 200,
      body: {
        success: true,
        message:
          "X√≥a th√¥ng tin ki·ªÉm tra th√†nh c√¥ng v√† ƒë√£ g·ª≠i th√¥ng b√°o h·ªßy cho h·ªçc sinh",
        data: {
          deletedTestInfo: {
            testInfoId: testInfo._id,
            title: testInfo.title,
            testType: testInfo.testType,
            class: testInfo.class.className,
            subject: testInfo.subject.subjectName,
          },
          emailInfo: {
            studentsFound: students.length,
            cancellationEmailsSent:
              students.length > 0
                ? "ƒêang g·ª≠i email h·ªßy..."
                : "Kh√¥ng c√≥ h·ªçc sinh n√†o c√≥ email",
          },
        },
      },
    };
  }
  async getUpcomingTestInfos({ user, query }) {
    const teacherId = user._id;
    const { days = 7 } = query;
    const upcomingTestInfos = await TestInfo.getUpcomingTestInfos(
      teacherId,
      parseInt(days)
    );
    return {
      status: 200,
      body: {
        success: true,
        message: `L·∫•y th√¥ng tin ki·ªÉm tra ${days} ng√†y t·ªõi th√†nh c√¥ng`,
        data: {
          upcomingTestInfos: upcomingTestInfos.map((testInfo) => ({
            testInfoId: testInfo._id,
            lesson: {
              lessonId: testInfo.lesson.lessonId,
              scheduledDate: testInfo.lesson.scheduledDate,
              topic: testInfo.lesson.topic,
            },
            class: testInfo.class.className,
            subject: {
              name: testInfo.subject.subjectName,
              code: testInfo.subject.subjectCode,
            },
            testType: testInfo.testType,
            title: testInfo.title,
            expectedTestDate: testInfo.expectedTestDate,
            priority: testInfo.priority,
            daysUntilTest: Math.ceil(
              (new Date(testInfo.expectedTestDate) - new Date()) /
                (1000 * 60 * 60 * 24)
            ),
          })),
          totalUpcoming: upcomingTestInfos.length,
        },
      },
    };
  }
  async markTestInfoCompleted({ user, params }) {
    const { testInfoId } = params;
    const teacherId = user._id;
    const testInfo = await TestInfo.findById(testInfoId);
    if (!testInfo) {
      return {
        status: 404,
        body: { success: false, message: "Test info not found" },
      };
    }
    if (testInfo.teacher.toString() !== teacherId.toString()) {
      return {
        status: 403,
        body: {
          success: false,
          message: "You can only update your own test info",
        },
      };
    }
    await testInfo.markCompleted();
    return {
      status: 200,
      body: {
        success: true,
        message: "ƒê√°nh d·∫•u ho√†n th√†nh th√¥ng tin ki·ªÉm tra th√†nh c√¥ng",
        data: {
          testInfoId: testInfo._id,
          status: testInfo.status,
          updatedAt: testInfo.updatedAt,
        },
      },
    };
  }
  async getTestInfoStats({ user, query }) {
    const teacherId = user._id;
    const { startDate, endDate } = query;
    const options = {};
    if (startDate) options.startDate = new Date(startDate);
    if (endDate) options.endDate = new Date(endDate);
    const stats = await TestInfo.getTestInfoStats(teacherId, options);
    return {
      status: 200,
      body: {
        success: true,
        message: "L·∫•y th·ªëng k√™ th√¥ng tin ki·ªÉm tra th√†nh c√¥ng",
        data: stats,
      },
    };
  }
  async resendTestInfoEmail({ user, params }) {
    const { testInfoId } = params;
    const teacherId = user._id;
    const testInfo = await TestInfo.findById(testInfoId)
      .populate("lesson", "lessonId scheduledDate topic")
      .populate("class", "_id className")
      .populate("subject", "subjectName subjectCode")
      .populate("teacher", "name");
    if (!testInfo) {
      return {
        status: 404,
        body: { success: false, message: "Test info not found" },
      };
    }
    if (testInfo.teacher._id.toString() !== teacherId.toString()) {
      return {
        status: 403,
        body: {
          success: false,
          message: "You can only resend emails for your own test info",
        },
      };
    }
    const students = await User.find({
      class_id: testInfo.class._id,
      role: { $in: ["student"] },
      email: { $exists: true, $ne: null, $ne: "" },
    }).select("_id name email studentId");
    if (students.length === 0) {
      return {
        status: 400,
        body: {
          success: false,
          message: "No students with email found in this class",
        },
      };
    }
    const testInfoEmailData = {
      lesson: {
        lessonId: testInfo.lesson.lessonId,
        scheduledDate: testInfo.lesson.scheduledDate,
        topic: testInfo.lesson.topic,
      },
      class: { className: testInfo.class.className },
      subject: {
        name: testInfo.subject.subjectName,
        code: testInfo.subject.subjectCode,
      },
      testType: testInfo.testType,
      title: testInfo.title,
      content: testInfo.content,
      chapters: testInfo.chapters,
      references: testInfo.references,
      expectedTestDate: testInfo.expectedTestDate,
      priority: testInfo.priority,
      reminder: testInfo.reminder,
    };
    const emailResults = await this.sendTestInfoToStudents(
      testInfoEmailData,
      students
    );
    return {
      status: 200,
      body: {
        success: true,
        message: "G·ª≠i l·∫°i email th√¥ng tin ki·ªÉm tra th√†nh c√¥ng",
        data: {
          testInfoId: testInfo._id,
          title: testInfo.title,
          class: testInfo.class.className,
          emailResults,
        },
      },
    };
  }
  async testTestInfoEmail({ user, params, body }) {
    const { testInfoId } = params;
    const { testEmail } = body;
    const teacherId = user._id;
    if (!testEmail) {
      return {
        status: 400,
        body: { success: false, message: "Test email is required" },
      };
    }
    const testInfo = await TestInfo.findById(testInfoId)
      .populate("lesson", "lessonId scheduledDate topic")
      .populate("class", "className")
      .populate("subject", "subjectName subjectCode")
      .populate("teacher", "name");
    if (!testInfo) {
      return {
        status: 404,
        body: { success: false, message: "Test info not found" },
      };
    }
    if (testInfo.teacher._id.toString() !== teacherId.toString()) {
      return {
        status: 403,
        body: {
          success: false,
          message: "You can only test emails for your own test info",
        },
      };
    }
    const testInfoEmailData = {
      lesson: {
        lessonId: testInfo.lesson.lessonId,
        scheduledDate: testInfo.lesson.scheduledDate,
        topic: testInfo.lesson.topic,
      },
      class: { className: testInfo.class.className },
      subject: {
        name: testInfo.subject.subjectName,
        code: testInfo.subject.subjectCode,
      },
      testType: testInfo.testType,
      title: testInfo.title,
      content: testInfo.content,
      chapters: testInfo.chapters,
      references: testInfo.references,
      expectedTestDate: testInfo.expectedTestDate,
      priority: testInfo.priority,
      reminder: testInfo.reminder,
    };
    const subject = `üß™ [TEST] Th√¥ng b√°o ki·ªÉm tra: ${testInfoEmailData.subject.name} - L·ªõp ${testInfoEmailData.class.className}`;
    const htmlContent = createTestInfoEmailTemplate(
      testInfoEmailData,
      "Test Student"
    );
    const result = await emailService.sendEmail(
      testEmail,
      subject,
      htmlContent
    );
    return {
      status: 200,
      body: {
        success: true,
        message: "G·ª≠i test email th√†nh c√¥ng",
        data: {
          testInfoId: testInfo._id,
          title: testInfo.title,
          testEmail: testEmail,
          messageId: result.messageId,
          message: result.message,
        },
      },
    };
  }
  async sendTestInfoToStudents(testInfoData, students) {
    try {
      const emailPromises = students.map(async (student) => {
        try {
          const subject = `üîî Th√¥ng b√°o ki·ªÉm tra: ${testInfoData.subject.name} - L·ªõp ${testInfoData.class.className}`;
          const htmlContent = createTestInfoEmailTemplate(
            testInfoData,
            student.name
          );
          const result = await emailService.sendEmail(
            student.email,
            subject,
            htmlContent
          );
          return {
            studentId: student._id,
            studentName: student.name,
            email: student.email,
            success: true,
            messageId: result.messageId,
            message: result.message || "Email sent successfully",
          };
        } catch (error) {
          return {
            studentId: student._id,
            studentName: student.name,
            email: student.email,
            success: false,
            error: error.message,
          };
        }
      });
      const results = await Promise.allSettled(emailPromises);
      const emailResults = results.map((result) =>
        result.status === "fulfilled" ? result.value : result.reason
      );
      const successCount = emailResults.filter((r) => r.success).length;
      const failCount = emailResults.filter((r) => !r.success).length;
      return {
        totalStudents: students.length,
        successCount,
        failCount,
        results: emailResults,
      };
    } catch (error) {
      throw error;
    }
  }
  async sendCancelTestInfoToStudents(testInfoData, students) {
    try {
      const emailPromises = students.map(async (student) => {
        try {
          const subject = `‚ùå TH√îNG B√ÅO H·ª¶Y: ${testInfoData.subject.name} - L·ªõp ${testInfoData.class.className}`;
          const htmlContent = createCancelTestInfoEmailTemplate(
            testInfoData,
            student.name
          );
          const result = await emailService.sendEmail(
            student.email,
            subject,
            htmlContent
          );
          return {
            studentId: student._id,
            studentName: student.name,
            email: student.email,
            success: true,
            messageId: result.messageId,
            message: result.message || "Cancellation email sent successfully",
          };
        } catch (error) {
          return {
            studentId: student._id,
            studentName: student.name,
            email: student.email,
            success: false,
            error: error.message,
          };
        }
      });
      const results = await Promise.allSettled(emailPromises);
      const emailResults = results.map((result) =>
        result.status === "fulfilled" ? result.value : result.reason
      );
      const successCount = emailResults.filter((r) => r.success).length;
      const failCount = emailResults.filter((r) => !r.success).length;
      return {
        totalStudents: students.length,
        successCount,
        failCount,
        results: emailResults,
      };
    } catch (error) {
      throw error;
    }
  }
}

module.exports = new TestInfoService();
