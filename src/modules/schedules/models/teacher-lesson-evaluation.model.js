const mongoose = require('mongoose');

const teacherLessonEvaluationSchema = new mongoose.Schema({
  // Th√¥ng tin c∆° b·∫£n
  lesson: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Lesson',
    required: true
  },
  
  teacher: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    validate: {
      validator: async function(teacherId) {
        const User = mongoose.model('User');
        const teacher = await User.findById(teacherId);
        return teacher && (teacher.role.includes('teacher') || teacher.role.includes('homeroom_teacher'));
      },
      message: 'Teacher ID must reference a valid teacher user'
    }
  },
  
  class: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Class',
    required: true
  },
  
  subject: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Subject',
    required: true
  },
  
  // Th√¥ng tin ti·∫øt h·ªçc
  lessonContent: {
    // Ti·∫øt ch∆∞∆°ng tr√¨nh (lesson number in curriculum)
    curriculumLesson: {
      type: String,
      required: true,
      trim: true,
      maxlength: 100
    },
    
    // N·ªôi dung b√†i h·ªçc
    content: {
      type: String,
      required: true,
      trim: true,
      maxlength: 1000
    },
    
    // M√¥ t·∫£ th√™m (optional)
    description: {
      type: String,
      trim: true,
      maxlength: 500
    }
  },
  
  // ƒê√°nh gi√° ch·∫•t l∆∞·ª£ng ti·∫øt h·ªçc
  evaluation: {
    // X·∫øp h·∫°ng: A+, A, B+, B, C
    rating: {
      type: String,
      required: true,
      enum: ['A+', 'A', 'B+', 'B', 'C'],
      validate: {
        validator: function(value) {
          return ['A+', 'A', 'B+', 'B', 'C'].includes(value);
        },
        message: 'Rating must be one of: A+, A, B+, B, C'
      }
    },
    
    // Nh·∫≠n x√©t c·ªßa gi√°o vi√™n
    comments: {
      type: String,
      trim: true,
      maxlength: 1000
    },
    
    // ƒê√°nh gi√° chi ti·∫øt (optional)
    details: {
      // M·ª©c ƒë·ªô t∆∞∆°ng t√°c c·ªßa h·ªçc sinh
      studentEngagement: {
        type: String,
        enum: ['excellent', 'good', 'average', 'poor'],
        default: 'average'
      },
      
      // M·ª©c ƒë·ªô hi·ªÉu b√†i c·ªßa l·ªõp
      comprehensionLevel: {
        type: String,
        enum: ['excellent', 'good', 'average', 'poor'],
        default: 'average'
      },
      
      // Ho√†n th√†nh m·ª•c ti√™u b√†i h·ªçc
      objectiveCompletion: {
        type: String,
        enum: ['fully', 'mostly', 'partially', 'not_completed'],
        default: 'fully'
      }
    }
  },
  
  // Th√¥ng tin h·ªçc sinh v·∫Øng
  absentStudents: [{
    student: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      validate: {
        validator: async function(studentId) {
          const User = mongoose.model('User');
          const student = await User.findById(studentId);
          return student && student.role.includes('student');
        },
        message: 'Student ID must reference a valid student user'
      }
    },
    
    // V·∫Øng c√≥ ph√©p hay kh√¥ng
    isExcused: {
      type: Boolean,
      required: true,
      default: false
    },
    
    // L√Ω do v·∫Øng (n·∫øu c√≥)
    reason: {
      type: String,
      trim: true,
      maxlength: 200
    },
    
    // Th·ªùi gian ghi nh·∫≠n v·∫Øng
    recordedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Ki·ªÉm tra mi·ªáng
  oralTests: [{
    student: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      validate: {
        validator: async function(studentId) {
          const User = mongoose.model('User');
          const student = await User.findById(studentId);
          return student && student.role.includes('student');
        },
        message: 'Student ID must reference a valid student user'
      }
    },
    
    // ƒêi·ªÉm s·ªë (0-10)
    score: {
      type: Number,
      required: true,
      min: 0,
      max: 10,
      validate: {
        validator: function(value) {
          // Cho ph√©p ƒëi·ªÉm v·ªõi 1 ch·ªØ s·ªë th·∫≠p ph√¢n
          return Number.isFinite(value) && value >= 0 && value <= 10;
        },
        message: 'Score must be a number between 0 and 10'
      }
    },
    
    // N·ªôi dung c√¢u h·ªèi/b√†i ki·ªÉm tra
    question: {
      type: String,
      trim: true,
      maxlength: 500
    },
    
    // Nh·∫≠n x√©t
    comment: {
      type: String,
      trim: true,
      maxlength: 300
    },
    
    // Th·ªùi gian ki·ªÉm tra
    testedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Vi ph·∫°m c·ªßa h·ªçc sinh
  violations: [{
    student: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      validate: {
        validator: async function(studentId) {
          const User = mongoose.model('User');
          const student = await User.findById(studentId);
          return student && student.role.includes('student');
        },
        message: 'Student ID must reference a valid student user'
      }
    },
    
    // M√¥ t·∫£ vi ph·∫°m
    description: {
      type: String,
      required: true,
      trim: true,
      maxlength: 500
    },
    
    // Lo·∫°i vi ph·∫°m
    type: {
      type: String,
      enum: ['late', 'disruptive', 'unprepared', 'disrespectful', 'cheating', 'other'],
      default: 'other'
    },
    
    // M·ª©c ƒë·ªô nghi√™m tr·ªçng
    severity: {
      type: String,
      enum: ['minor', 'moderate', 'serious'],
      default: 'minor'
    },
    
    // Bi·ªán ph√°p x·ª≠ l√Ω
    action: {
      type: String,
      trim: true,
      maxlength: 300
    },
    
    // Th·ªùi gian ghi nh·∫≠n vi ph·∫°m
    recordedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Th·ªëng k√™ t·ªïng quan
  summary: {
    // T·ªïng s·ªë h·ªçc sinh c√≥ m·∫∑t
    totalPresent: {
      type: Number,
      default: 0
    },
    
    // T·ªïng s·ªë h·ªçc sinh v·∫Øng
    totalAbsent: {
      type: Number,
      default: 0
    },
    
    // S·ªë h·ªçc sinh v·∫Øng c√≥ ph√©p
    totalExcusedAbsent: {
      type: Number,
      default: 0
    },
    
    // S·ªë h·ªçc sinh ki·ªÉm tra mi·ªáng
    totalOralTests: {
      type: Number,
      default: 0
    },
    
    // ƒêi·ªÉm trung b√¨nh ki·ªÉm tra mi·ªáng
    averageOralScore: {
      type: Number,
      default: 0
    },
    
    // T·ªïng s·ªë vi ph·∫°m
    totalViolations: {
      type: Number,
      default: 0
    }
  },
  
  // Tr·∫°ng th√°i ƒë√°nh gi√°
  status: {
    type: String,
    enum: ['draft', 'completed', 'submitted'],
    default: 'draft'
  },
  
  // Th·ªùi gian ho√†n th√†nh ƒë√°nh gi√°
  completedAt: {
    type: Date
  },
  
  // Th·ªùi gian submit ƒë√°nh gi√°
  submittedAt: {
    type: Date
  }
}, {
  timestamps: true
});

// Indexes
teacherLessonEvaluationSchema.index({ lesson: 1, teacher: 1 }, { unique: true }); // M·ªói gi√°o vi√™n ch·ªâ ƒë√°nh gi√° 1 l·∫ßn cho 1 ti·∫øt
teacherLessonEvaluationSchema.index({ teacher: 1, createdAt: -1 });
teacherLessonEvaluationSchema.index({ class: 1, createdAt: -1 });
teacherLessonEvaluationSchema.index({ subject: 1, createdAt: -1 });
teacherLessonEvaluationSchema.index({ status: 1 });
teacherLessonEvaluationSchema.index({ 'evaluation.rating': 1 });

// Pre-save middleware ƒë·ªÉ t√≠nh to√°n summary
teacherLessonEvaluationSchema.pre('save', function(next) {
  // T√≠nh t·ªïng s·ªë h·ªçc sinh v·∫Øng
  this.summary.totalAbsent = this.absentStudents.length;
  this.summary.totalExcusedAbsent = this.absentStudents.filter(absent => absent.isExcused).length;
  
  // T√≠nh th·ªëng k√™ ki·ªÉm tra mi·ªáng
  this.summary.totalOralTests = this.oralTests.length;
  if (this.oralTests.length > 0) {
    const totalScore = this.oralTests.reduce((sum, test) => sum + test.score, 0);
    this.summary.averageOralScore = Math.round((totalScore / this.oralTests.length) * 10) / 10;
  } else {
    this.summary.averageOralScore = 0;
  }
  
  // T√≠nh t·ªïng s·ªë vi ph·∫°m
  this.summary.totalViolations = this.violations.length;
  
  // T√≠nh s·ªë h·ªçc sinh c√≥ m·∫∑t (c·∫ßn l·∫•y t·ª´ lesson)
  // S·∫Ω ƒë∆∞·ª£c t√≠nh trong controller khi c√≥ th√¥ng tin ƒë·∫ßy ƒë·ªß
  
  next();
});

// Pre-save validation
teacherLessonEvaluationSchema.pre('save', async function(next) {
  try {
    const Lesson = mongoose.model('Lesson');
    const User = mongoose.model('User');
    
    // Ki·ªÉm tra lesson t·ªìn t·∫°i v√† gi√°o vi√™n c√≥ quy·ªÅn ƒë√°nh gi√°
    const lesson = await Lesson.findById(this.lesson);
    if (!lesson) {
      throw new Error('Lesson not found');
    }
    
    // Ki·ªÉm tra gi√°o vi√™n c√≥ ph·∫£i l√† gi√°o vi√™n d·∫°y ti·∫øt n√†y kh√¥ng
    if (lesson.teacher.toString() !== this.teacher.toString()) {
      throw new Error('Teacher can only evaluate their own lessons');
    }
    
    // Ki·ªÉm tra lesson c√≥ th·ªÉ ƒë√°nh gi√° kh√¥ng (ch·ªâ ƒë√°nh gi√° lesson scheduled)
    if (lesson.status !== 'scheduled') {
      throw new Error('Can only evaluate scheduled lessons');
    }
    
    // Ki·ªÉm tra th√¥ng tin class v√† subject kh·ªõp v·ªõi lesson
    if (lesson.class.toString() !== this.class.toString()) {
      throw new Error('Class mismatch with lesson');
    }
    
    if (lesson.subject.toString() !== this.subject.toString()) {
      throw new Error('Subject mismatch with lesson');
    }
    
    // Ki·ªÉm tra t·∫•t c·∫£ h·ªçc sinh trong danh s√°ch thu·ªôc l·ªõp n√†y
    const allStudentIds = [
      ...this.absentStudents.map(a => a.student),
      ...this.oralTests.map(o => o.student),
      ...this.violations.map(v => v.student)
    ];
    
    if (allStudentIds.length > 0) {
      // Lo·∫°i b·ªè duplicate student IDs
      const uniqueStudentIds = [...new Set(allStudentIds.map(id => id.toString()))];
      
      console.log('üîç Debug validation:');
      console.log('- Class ID:', this.class.toString());
      console.log('- Unique Student IDs:', uniqueStudentIds);
      
      const students = await User.find({
        _id: { $in: uniqueStudentIds },
        class_id: this.class,
        role: 'student'
      });
      
      console.log('- Found students:', students.length);
      console.log('- Students found:', students.map(s => ({ id: s._id.toString(), name: s.name, class_id: s.class_id.toString() })));
      
      if (students.length !== uniqueStudentIds.length) {
        const foundIds = students.map(s => s._id.toString());
        const missingIds = uniqueStudentIds.filter(id => !foundIds.includes(id));
        console.log('- Missing student IDs:', missingIds);
        throw new Error(`Some students do not belong to this class. Missing: ${missingIds.join(', ')}`);
      }
    }
    
    next();
  } catch (error) {
    next(error);
  }
});

// Static methods
teacherLessonEvaluationSchema.statics.getTeacherEvaluations = function(teacherId, options = {}) {
  const query = { teacher: teacherId };
  
  if (options.classId) query.class = options.classId;
  if (options.subjectId) query.subject = options.subjectId;
  if (options.status) query.status = options.status;
  if (options.rating) query['evaluation.rating'] = options.rating;
  if (options.startDate) query.createdAt = { $gte: options.startDate };
  if (options.endDate) {
    query.createdAt = { ...query.createdAt, $lte: options.endDate };
  }
  
  return this.find(query)
    .populate('lesson', 'lessonId scheduledDate actualDate topic')
    .populate('class', 'className')
    .populate('subject', 'subjectName subjectCode')
    .populate('absentStudents.student', 'name studentId')
    .populate('oralTests.student', 'name studentId')
    .populate('violations.student', 'name studentId')
    .sort({ createdAt: -1 });
};

// Static method ƒë·ªÉ l·∫•y th·ªëng k√™ ƒë√°nh gi√° c·ªßa gi√°o vi√™n
teacherLessonEvaluationSchema.statics.getTeacherEvaluationStats = async function(teacherId, options = {}) {
  const matchQuery = { teacher: teacherId };
  
  if (options.startDate) matchQuery.createdAt = { $gte: options.startDate };
  if (options.endDate) {
    matchQuery.createdAt = { ...matchQuery.createdAt, $lte: options.endDate };
  }
  if (options.subjectId) matchQuery.subject = options.subjectId;
  if (options.classId) matchQuery.class = options.classId;
  
  const stats = await this.aggregate([
    { $match: matchQuery },
    {
      $group: {
        _id: null,
        totalEvaluations: { $sum: 1 },
        avgOralScore: { $avg: '$summary.averageOralScore' },
        totalAbsences: { $sum: '$summary.totalAbsent' },
        totalViolations: { $sum: '$summary.totalViolations' },
        ratingDistribution: {
          $push: '$evaluation.rating'
        }
      }
    }
  ]);
  
  if (stats.length === 0) {
    return {
      totalEvaluations: 0,
      avgOralScore: 0,
      totalAbsences: 0,
      totalViolations: 0,
      ratingDistribution: {}
    };
  }
  
  const result = stats[0];
  
  // T√≠nh ph√¢n b·ªë rating
  const ratingCounts = result.ratingDistribution.reduce((acc, rating) => {
    acc[rating] = (acc[rating] || 0) + 1;
    return acc;
  }, {});
  
  return {
    totalEvaluations: result.totalEvaluations,
    avgOralScore: Math.round(result.avgOralScore * 10) / 10,
    totalAbsences: result.totalAbsences,
    totalViolations: result.totalViolations,
    ratingDistribution: ratingCounts
  };
};

// Instance methods
teacherLessonEvaluationSchema.methods.addAbsentStudent = function(studentId, isExcused = false, reason = '') {
  // Ki·ªÉm tra h·ªçc sinh ƒë√£ c√≥ trong danh s√°ch v·∫Øng ch∆∞a
  const existingIndex = this.absentStudents.findIndex(
    absent => absent.student.toString() === studentId.toString()
  );
  
  if (existingIndex >= 0) {
    // C·∫≠p nh·∫≠t th√¥ng tin
    this.absentStudents[existingIndex].isExcused = isExcused;
    this.absentStudents[existingIndex].reason = reason;
    this.absentStudents[existingIndex].recordedAt = new Date();
  } else {
    // Th√™m m·ªõi
    this.absentStudents.push({
      student: studentId,
      isExcused,
      reason,
      recordedAt: new Date()
    });
  }
  
  return this.save();
};

teacherLessonEvaluationSchema.methods.addOralTest = function(studentId, score, question = '', comment = '') {
  this.oralTests.push({
    student: studentId,
    score,
    question,
    comment,
    testedAt: new Date()
  });
  
  return this.save();
};

teacherLessonEvaluationSchema.methods.addViolation = function(studentId, description, type = 'other', severity = 'minor', action = '') {
  this.violations.push({
    student: studentId,
    description,
    type,
    severity,
    action,
    recordedAt: new Date()
  });
  
  return this.save();
};

teacherLessonEvaluationSchema.methods.complete = function() {
  this.status = 'completed';
  this.completedAt = new Date();
  return this.save();
};

teacherLessonEvaluationSchema.methods.submit = function() {
  this.status = 'submitted';
  this.submittedAt = new Date();
  if (!this.completedAt) {
    this.completedAt = new Date();
  }
  return this.save();
};

const TeacherLessonEvaluation = mongoose.model('TeacherLessonEvaluation', teacherLessonEvaluationSchema);

module.exports = TeacherLessonEvaluation;